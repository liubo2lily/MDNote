# 1 休眠唤醒机制

## 1.0 引言

该机制核心点在于**事件标志变量**以及**等待队列**，在按键休眠唤醒中，**事件标志变量**与**键值**复用，流程概述来说就是初始化**等待序列**与**事件标志变量**后，在**read函数**中休眠，在**isr**中设置**事件标志变量**，并唤醒，唤醒后，**read函数**要将**事件标志变量**清零。

## 1.1 框架描述

**a. 使用宏初始化等待队列**

```c
static DECLARE_WAIT_QUEUE_HEAD(xxx_wait);
```

**b. 定义全局事件标志变量**

```c
static int event = 0;
```

该变量取0为休眠，非0则唤醒。

**c. 读函数调用wait_event_interruptible进入休眠模式**

```c
#define wait_event_interruptible(wait_queue_head_t wq, condition)
```

参数wq传入等待队列，参数condition传入事件标志变量。

**d. 中断服务函数中修改事件标志变量**

**e. 中断服务函数中调用唤醒等待队列**

```c
#define wake_up_interruptible(wait_queue_head_t* wq)
```

注：这里需要传入的是指针。

**f. 读函数被唤醒后，进行正常读逻辑，并将事件标志变量置0**

***********

# 2 poll机制

## 2.0 引言

由于休眠唤醒机制，一旦进入休眠，那么进程就无法去做其他事，poll机制便是在休眠唤醒机制中添加了超时机制，若给定时间内没有唤醒，则自行唤醒。内核中的poll已经把休眠部分给封装进去了，因此poll机制的结构十分简单。**注：**poll在定时前和定时后分别执行一次。

## 2.1 框架描述-内核态

**a. 使用宏初始化等待队列**

```c
static DECLARE_WAIT_QUEUE_HEAD(xxx_wait);
```

**b. 定义编写xxx_drv_poll函数并初始化file_operations结构体**

```c
static unsigned int xxx_drv_poll(struct file *fp, poll_table * wait)
{
	poll_wait(fp, &xxx_wait, wait);
	return event ? 0 : POLLIN | POLLRDNORM;
}
static struct file_operations xxx_fops = {
	.owner	 = THIS_MODULE,
	.read    = xxx_drv_read,
	.poll    = xxx_drv_poll,
};
```

函数返回值相当于休眠唤醒中的事件标志变量，0为未发生，POLLIN与POLLRDNORM均为有数据可读，后者是为了兼容老版应用程序，而POLLOUT与POLLWRNORM则代表可以写数据。

**c. 在xxx_drv_poll函数中调用poll_wait**

```c
void poll_wait(struct file * filp, wait_queue_head_t * wait_address, poll_table * p);
```

该函数封装了休眠与poll相关的代码，一个函数，即可完成所有工作。

**d. 中断服务函数中调用唤醒等待队列**

```c
#define wake_up_interruptible(wait_queue_head_t* wq)
```

注：这里需要传入的是指针。

**e. 进行读函数正常逻辑**

## 2.2 框架描述-用户态

**a. 定义struct pollfd结构体数组**

```c
struct pollfd fds[n];
```

poll可以同时监测多个文件，因此需要定义该数组。

**b. 初始化struct pollfd结构体数组**

```c
struct pollfd {
	int fd;
	short events;
	short revents;
};
fds[n].fd = fd;
fds[n].events = POLLIN;
```

结构体初始化的就是文件描述符**fd**以及等待的事件**events**，而**revents**成员代表接收回来的事件。

**c. 调用poll函数**

```c
int poll(struct pollfd *fds, nfds_t nfds, int timeout);
```

参数**fds**为定义的pollfd结构体数组，参数**nfds**为结构体数组的长度即检测的文件数，参数**timeout**为超时时间，以ms为单位，**返回值**为非零revents的个数，0表示没准备好，负数代表失败。

**d. 判断poll的返回值**

```c
ret = poll(fds, 1, timeout_ms);
if ((ret == 1) && (fds[0].revents & POLLIN)) {
    read(fd, &val, 4);
    //...
}
else {
    printf("timeout\n");
}
```

参数**fds**为定义的pollfd结构体数组，参数**nfds**为结构体数组的长度即检测的文件数，参数**timeout**为超时时间，以ms为单位，**返回值**为非零revents的个数，0表示没准备好，负数代表失败。

# 3 异步通知（软中断）

## 3.0 引言

无论是休眠唤醒还是poll机制，内核态均处于一种被动等待读取的状态，而异步通知机制，是由内核态主动发送信号，用户态收到信号，在信号处理函数中，进行数据读取。

## 3.1 框架描述-内核态

**a. 定义fasync_struct结构体**

```c
struct fasync_struct *xxx_fasync;
```

**b. 定义编写xxx_drv_fasync函数并初始化file_operations结构体**

```c
static int gpio_key_drv_fasync(int fd, struct file *file, int on)
{
	if (fasync_helper(fd, file, on, &xxx_fasync) >= 0)
		return 0;
	else
		return -EIO;
}
static struct file_operations xxx_fops = {
	.owner	 = THIS_MODULE,
	.read    = xxx_drv_read,
	.fasync  = xxx_drv_fasync,
};
```

**c. 在xxx_drv_fasync中初始化fasync**

```c
int fasync_helper(int fd, struct file * filp, int on, struct fasync_struct **fapp);
```

该函数用以初始化**fasync**，用户态通过设置**flags**的**FASYNC**位打开异步通知，参数**on**就会开启，反之则会关闭。

**d. 在中断服务函数中发送信号**

```c
void kill_fasync(struct fasync_struct **fp, int sig, int band);
//e.g.
kill_fasync(&xxx_fasync, SIGIO, POLL_IN);
```

其中**band**（目前接触的，没有太深入）**POLL_IN**代表可读**POLL_OUT**代表可写。

**e. 进行读函数正常逻辑**

## 3.2 框架描述-用户态

**a. 定义信号处理函数**

```c
static void sig_handler(int sig)
{
    //...
}
```

**b. 注册信号处理函数**

```c
sighandler_t signal(int signum, sighandler_t handler);
//e.g.
signal(SIGIO, sig_handler);
```

**c. 为设备设置PID**

```c
fcntl(fd, F_SETOWN, getpid());
```

**d. 读取保存flags**

```c
int	flags;
flags = fcntl(fd, F_GETFL);
```

**e. flags基础上添加FASYNC并设置flags**

```c
fcntl(fd, F_SETFL, flags | FASYNC);
```

**f. 信号处理函数正常逻辑**

**************

# 4 阻塞与非阻塞

## 4.0 引言

用户态定义了阻塞与非阻塞两种状态，如按键操作，用户可以通过指定阻塞状态，决定是poll还是立刻返回，这就需要驱动程序也对该机制进行支持。核心是**O_NONBLOCK**标志值，由用户态设置用以决定使用哪种方式执行，由驱动端读取用以对各种方式进行代码上的实现。

## 4.1 框架描述-内核态

**a. 在需要编写的函数中提取flags变量**

```c
int flags = file->f_flags;
```

**b. 分析flags变量成分，根据是否含有O_NONBLOCK，编写相应的代码**

```c
int is_nonblock = f_flags & O_NONBLOCK;
```

## 4.2 框架描述-用户态

**a. 可以在open函数指定是否阻塞**

```c
fd = open(argv[1], O_RDWR | O_NONBLOCK);
```

**b. 可以通过F_GETFL和F_SETFL设定阻塞状态**

```c
flags = fcntl(fd, F_GETFL);					//获取当前flags
fcntl(fd, F_SETFL, flags & ~O_NONBLOCK);	//阻塞
fcntl(fd, F_SETFL, flags | O_NONBLOCK);		//非阻塞
```

# 5 内核定时器

## 5.0 引言

内核定时器是一种软中断，记住两大要素，就相当于掌握了寄存器，**超时时间**和**超时之后做什么**，好的驱动程序，贴合面向对象的思想，会将定时器结构体作为成员变量

## 5.1 框架描述-旧内核

**a. 在设备自定义结构体中加入struct timer_list成员**

```c
struct xxx_dev{
	//...
	struct timer_list xxx_timer;
} ;
```

**b. 编写超时处理函数**

```c
static void xxx_timer_expire(unsigned long data)
{
	//...
}
```

**c. probe中调用setup_timer初始化定时器，包括定时器结构体及超时时间成员**

```c
setup_timer(timer, fn, data);
//e.g.
setup_timer(&xxx_dev.key_timer, key_timer_expire, &xxx_dev);
xxx_dev.xxx_timer.expires = ~0;
```

**d. 调用add_timer添加定时器**

```c
add_timer(&xxx_dev.xxx_timer);
```

**e. 中断或者需要定时的地方，调用mod_timer**

```c
int mod_timer(struct timer_list *timer, unsigned long expires);
//e.g.
mod_timer(&xxx_dev->xxx_timer, jiffies + HZ/50);	//CONFIG_HZ=100条件下，定时20ms
```

其中**jiffies**为全局变量，记录从起始到现在经过了多少滴答，滴答由CONFIG_HZ来设置。

**f. remove，调用del_timer删除定时器**

```c
int del_timer(struct timer_list *timer);
```

其中**jiffies**为全局变量，记录从起始到现在经过了多少滴答，滴答由CONFIG_HZ来设置。

## 5.2 框架描述-新内核需要修改

+ **超时处理函数需要修改**

```c
static void key_timer_expire(struct timer_list *t)
{
	struct xxx_dev *xxx_dev_m = from_timer(xxx_dev_m, t, xxx_timer);
	//...
}
```

+ **初始化定时器函数发生变化**

```c
void timer_setup(struct timer_list *timer,void (*callback)(struct timer_list *),unsigned int flags);
```

参数flags一般取NULL，/include/linux/timer.h + 60，等后期实际项目遇到了再填坑。

该函数无法直接传入data，只能在超时回调函数中通过参量**t**进行间接提取。

+ **在超时回调函数中调用from_timer函数反推数据**

```c
from_timer(var, callback_timer, timer_fieldname)
```

参数**var**表示需要反推的变量，参数**callback_timer**表示timer_list，参数**timer_fieldname**表示定时器在数据结构体中的名字。

# 6 中断下半部-tasklet

## 6.0 引言

**taklet**是一种软件中断，它用于解决硬件中断不好处理的一些费时工作，在使用过程中，可以在硬件中断中调度**tasklet**，由内核自动完成**tasklet**的运行，同一硬件中断无论发生多少次，**tasklet**只会执行一次，因此是多对一的关系。

## 6.1 框架描述

**a. 定义tasklet_struct结构体**

```c
struct tasklet_struct tasklet;
```

**b. 定义tasklet处理函数**

```c
static void xxx_tasklet_func(unsigned long data)
{
	//...
}
```

**c. probe函数调用tasklet_init初始化tasklet**

```c
void tasklet_init(struct tasklet_struct *t, void (*func)(unsigned long), unsigned long data);
//e.g.
tasklet_init(&tasklet, xxx_tasklet_func, &data);
```

**d. 在中断服务程序中调用tasklet_schedule调度tasklet，即把tasklet放入队列**

```c
void tasklet_schedule(struct tasklet_struct *tasklet);
```
**e. remove函数调用tasklet_kill注销tasklet**

```c
void tasklet_kill(struct tasklet_struct *t);
```

# 7 工作队列-workqueue

## 7.0 引言

无论是**硬中断**还是**tasklet**，进程都会陷入内核态一直执行，此时如果用户态需要进行一些紧急的事情，就要使用一种新的机制来解决这种应用场景，这种机制叫做**工作队列**，该机制会使用内核线程执行内核态代码，用户态可以与内核态平等的竞争执行机会。**既然是队列**，需要排队执行任务，因此这种机制不适合处理耗时较长的工作，对于这种，就单独的创建线程吧。

## 7.1 框架描述

**a. 定义work_struct结构体**

```c
struct work_struct m_work;
```

**b. 定义work处理函数**

```c
static void xxx_work_func(struct work_struct *work)
{
	struct gpio_key *gpio_key = container_of(work, struct xxx_dev, m_work);
}
```

使用**container_of**函数可以根据成员地址、成员在结构体里的名字以及结构体类型从而获取整个结构体的地址，其原型如下：

```c
#define container_of(ptr, type, member) \
    (type *)((char *)(ptr) - (char *) &((type *)0)->member)
```

**c. 调用INIT_WORK初始化work_struct**

```c
INIT_WORK(m_work, xxx_work_func);
```

**d. 在中断服务程序中调用schedule_work调度work，即把work放入队列**

```c
bool schedule_work(struct work_struct *work);
```

# 8 中断的线程化处理

## 8.0 引言

中断的线程化处理就是解决**工作队列**把所有**work**全都挤在一个线程的问题，使中断能有自己的线程来执行下半部代码。

## 8.1 框架描述

**a. 定义中断上半部处理函数，并返回IRQ_WAKE_THREAD**

```c
static irqreturn_t xxx_isr(int irq, void *dev_id)
{
	//...
	return IRQ_WAKE_THREAD;
}
```

**b. 定义中断下半部处理函数，并返回IRQ_HANDLED**

```c
static irqreturn_t xxx_thread_func(int irq, void *dev_id)
{
	//...	
	return IRQ_HANDLED;
}
```

**c. probe函数中调用request_threaded_irq初始化中断**

```c
int request_threaded_irq(unsigned int irq, irq_handler_t handler,
			 irq_handler_t thread_fn, unsigned long irqflags,
			 const char *devname, void *dev_id);
//e.g.
err = request_threaded_irq(irq, xxx_isr, xxx_thread_func, IRQF_TRIGGER_RISING, "xxx", &data);
```

其中参数**irq**代表中断号，参数**irqflags**代表触发中断的条件，对于GPIO有**IRQF_TRIGGER_RISING**和**IRQF_TRIGGER_FALLING**。
**d. remove函数中调用free_irq释放中断**

```c
void free_irq(unsigned int irq, void *dev_id);
```

