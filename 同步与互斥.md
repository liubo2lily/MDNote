## 参考资料

由于有关同步与互斥的内核源码离不开内联汇编，因此如需深入研究，需要参考以下资料

① GNU C扩展汇编 https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html

② ARM GCC 内嵌（inline）汇编手册 http://blog.chinaunix.net/uid-20543672-id-3194385.html

③ C内联汇编 https://akaedu.github.io/book/ch19s05.html

④ 内核同步机制（论坛牛）http://www.wowotech.net/kernel_synchronization/spinlock.html

## 0. 概念补充

* SMP全称Symmetric Multi-Processors，即对称多处理器。UP全称Uni-Processor，即单核处理器。

* 以ARMv6为分界线，之前为UP，之后为SMP，因此内核有两套代码处理同步与互斥。

* ldrex、strex指令可实现独占访问，ex代表exclude，使用示例如下：

  ① 读出：ldrex r0, [r1]

  读取r1所指内存的数据，存入r0；并且标记r1所指内存为“独占访问”。

  如果有其他程序再次执行“ldrex r0, [r1]”，一样会成功，一样会标记r1所指内存为“独占访问”。

  ② 修改r0的值

  ③ 写入：strex r2, r0, [r1]：

  如果r1的“独占访问”标记还存在，则把r0的新值写入r1所指内存，并且清除“独占访问”的标记，把r2设为0表示成功。

  如果r1的“独占访问”标记不存在了，就不会更新内存，并且把r2设为1表示失败。

## 1. 原子操作

### 1.1 原子变量

```c
typedef struct {
	int counter;    
} atomic_t;
```

| 函数名  (有关v的都是指针) | 作用                                             |
| ------------------------- | ------------------------------------------------ |
| atomic_read(v)            | 读出原子变量的值，即v->counter                   |
| atomic_set(v,i)           | 设置原子变量的值，即v->counter = i               |
| atomic_inc(v)             | v->counter++                                     |
| atomic_dec(v)             | v->counter--                                     |
| atomic_add(i,v)           | v->counter += i                                  |
| atomic_sub(i,v)           | v->counter -= i                                  |
| atomic_inc_and_test(v)    | 先加1，再判断新值是否等于0；等于0的话，返回值为1 |
| atomic_dec_and_test(v)    | 先减1，再判断新值是否等于0；等于0的话，返回值为1 |

**使用案例**

```c
static atomic_t valid = ATOMIC_INIT(1);
static ssize_t gpio_key_drv_open (struct inode *node, struct file *file)
{
    if (atomic_dec_and_test(&valid)) {
        return 0;
    }
    atomic_inc(&valid);
    return -EBUSY;
}
static int gpio_key_drv_close (struct inode *node, struct file *file)
{
    atomic_inc(&valid);
    return 0;
}
```

### 1.2 原子位

| 函数名                    | 作用                                                     |
| ------------------------- | -------------------------------------------------------- |
| set_bit(nr,p)             | 设置(*p)的bit nr为1                                      |
| clear_bit(nr,p)           | 清除(*p)的bit nr为0                                      |
| change_bit(nr,p)          | 改变(*p)的bit nr，从1变为0，或是从0变为1                 |
| test_and_set_bit(nr,p)    | 设置(*p)的bit nr为1，返回该位的老值                      |
| test_and_clear_bit(nr,p)  | 清除(*p)的bit nr为0，返回该位的老值                      |
| test_and_change_bit(nr,p) | 改变(*p)的bit nr，从1变为0，或是从0变为1；返回该位的老值 |

## 2. 自旋锁(Spinlock)

```c
typedef struct {
	unsigned int x;
} spinlock_t;
```

| 函数名                               | 作用                                         |
| ------------------------------------ | -------------------------------------------- |
| DEFINE_SPINLOCK(x)                   | 定义并初始化struct spinlock_t                |
| spin_lock_init(_lock)                | 初始化自旋锁为unlock状态                     |
| void spin_lock(spinlock_t *lock)     | 获取自旋锁(加锁)，返回后肯定获得了锁         |
| int spin_trylock(spinlock_t *lock)   | 尝试获得自旋锁，成功获得锁则返回1，否则返回0 |
| void spin_unlock(spinlock_t *lock)   | 释放自旋锁，或称解锁                         |
| int spin_is_locked(spinlock_t *lock) | 返回自旋锁的状态，已加锁返回1，否则返回0     |

加锁、解锁函数可以加上各种后缀，这表示一些做额外的事情。

| 后缀               | 描述                                                     |
| ------------------ | -------------------------------------------------------- |
| _bh()              | 加锁时禁止下半部(软中断)，解锁时使能下半部(软中断)       |
| _irq()             | 加锁时禁止中断，解锁时使能中断                           |
| _irqsave/restore() | 加锁时禁止并中断并记录状态，解锁时恢复中断为所记录的状态 |

**使用案例**

```c
static DEFINE_SPINLOCK(lock); // static spinlock_t lock; spin_lock_init(&lock);
spin_lock_bh(&lock);
/* 临界区 */
spin_unlock_bh(&lock);
```

## 3. 信号量(Semaphore)多把锁

```c
struct semaphore {
	raw_spinlock_t		lock;
	unsigned int		count;
	struct list_head	wait_list;
};
```

| 函数名                                                | 作用                                                         |
| ----------------------------------------------------- | ------------------------------------------------------------ |
| DEFINE_SEMAPHORE(name)                                | 定义一个struct semaphore name结构体，  count值设置为1        |
| void sema_init(struct semaphore *sem, int val)        | 初始化semaphore                                              |
| void down(struct semaphore *sem)                      | 获得信号量，如果暂时无法获得就会休眠<br>返回之后就表示肯定获得了信号量<br/>在休眠过程中无法被唤醒，<br/>即使有信号发给这个进程也不处理 |
| int down_interruptible(struct semaphore *sem)         | 获得信号量，如果暂时无法获得就会休眠，<br/>休眠过程有可能收到信号而被唤醒，<br/>要判断返回值：0：获得了信号量-EINTR：被信号打断 |
| int down_killable(struct semaphore *sem)              | 跟down_interruptible类似，<br/>down_interruptible可以被任意信号唤醒，<br/>但down_killable只能被“fatal signal”唤醒，<br/>返回值：  0：获得了信号量  -EINTR：被信号打断 |
| int down_trylock(struct semaphore *sem)               | 尝试获得信号量，不会休眠，  返回值：  0：获得了信号量  1：没能获得信号量 |
| int down_timeout(struct semaphore *sem, long jiffies) | 获得信号量，如果不成功，休眠一段时间<br/>返回值：  0：获得了信号量<br/>-ETIME：超时返回  down_timeout休眠过程中，它不会被信号唤醒 |
| void up(struct semaphore *sem)                        | 释放信号量，唤醒其他等待信号量的进程                         |

**使用案例**

```c
static DEFINE_SPINLOCK(clock_lock); // 或 struct semaphore sem;  sema_init(&sem, 1);
if (down_interruptible(&sem))  // if (down_trylock(&sem))
{
    /* 获得了信号量 */
}
/* 释放信号量 */
up(&sem); 
```

## 4. 互斥量(mutex)一把锁

```c
struct mutex {
	atomic_t		count;				/* 1: unlocked, 0: locked, negative: locked, possible waiters */
	spinlock_t		wait_lock;
	struct list_head	wait_list;
	struct task_struct	*owner;			/* CONFIG_DEBUG_MUTEXES || CONFIG_MUTEX_SPIN_ON_OWNER */
	struct optimistic_spin_queue osq; 	/* CONFIG_MUTEX_SPIN_ON_OWNER */ /* Spinner MCS lock */ 
	void			*magic;				/* CONFIG_DEBUG_MUTEXES */
	struct lockdep_map	dep_map;		/* CONFIG_DEBUG_LOCK_ALLOC */
};
```

| 函数名                                                       | 作用                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| mutex_init(mutex)                                            | 初始化一个struct mutex指针                                   |
| DEFINE_MUTEX(mutexname)                                      | 定义并，初始化struct mutex                                   |
| int mutex_is_locked(struct mutex *lock)                      | 判断mutex的状态<br/>1：被锁了(locked)  0：没有被锁           |
| void mutex_lock(struct mutex *lock)                          | 获得mutex，如果暂时无法获得，休眠<br/>返回之时必定是已经获得了mutex |
| int mutex_lock_interruptible(struct mutex *lock)             | 获得mutex，如果暂时无法获得，休眠;  休眠过程中可以被信号唤醒，<br/>0：成功获得了mutex  -EINTR：被信号唤醒了 |
| int mutex_lock_killable(struct mutex *lock)                  | mutex_lock_killable只能被“fatal signal”唤醒，<br/>0：获得了mutex，  -EINTR：被信号打断 |
| int mutex_trylock(struct mutex *lock)                        | 尝试获取mutex，如果无法获得，不会休眠，<br/>1：获得了mutex，  0：没有获得<br/>注意，这个返回值含义跟一般的mutex函数相反， |
| void mutex_unlock(struct mutex *lock)                        | 释放mutex，会唤醒其他等待同一个mutex的线程                   |
| int atomic_dec_and_mutex_lock(atomic_t *cnt, struct mutex *lock) | 让原子变量的值减1，  如果减1后等于0，则获取mutex，<br/>1：原子变量等于0并且获得了mutex <br/>0：原子变量减1后并不等于0，没有获得mutex |

**使用案例**

```c
static DEFINE_MUTEX(mutex);  //或 static struct mutex mutex; mutex_init(&mutex);
mutex_lock(&mutex);
/* 临界区 */
mutex_unlock(&mutex);
```

