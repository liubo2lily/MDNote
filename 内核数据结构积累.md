### 环形缓冲区(读完即丢)

算法描述(假设缓冲区大小为4)

```shell
		R=0
		||
		\/
buf[0]->[0][1][2][3]
        ||
        \/
		W=0
1、空, R==W
2、写, buf[W]=val, W = (W+1)%4; //到尽头就重新来
3、读, buf[R]=val, R = (R+1)%4; //到尽头就重新来
4、满, (W+1)%4 == R
```

编程

```c
#define len 4
int buf[len];
static int r = 0;
static int w = 0;
static int is_empty(void)
{
	return (r == w);
}
static int is_full(void)
{
	return ((w + 1) % len == r);
}
static void put(int x)
{
	if (is_full()) {
		r = (r + 1) % len; //如果满了还要写，就丢一个
	}
	buf[w] = x;
	w = (w + 1) % len;
}
static int get(int* p)
{
	if (is_empty) {
		return 0;
	}
	*p = buf[r];
	r = (r + 1) % len;
	
	return 1;
} 
```

